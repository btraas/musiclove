# 1 "Main.xmi"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 388 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/Users/brayden/theos/Prefix.pch" 1
# 10 "/Users/brayden/theos/Prefix.pch"
# 1 "/Users/brayden/theos/include/_Prefix/BackwardsCompat.h" 1
# 11 "/Users/brayden/theos/Prefix.pch" 2
#pragma clang module import Foundation /* clang -E: implicit import for #import <Foundation/Foundation.h> */








#pragma clang module import UIKit /* clang -E: implicit import for #import <UIKit/UIKit.h> */
# 1 "/Users/brayden/theos/include/_Prefix/IOSMacros.h" 1
# 22 "/Users/brayden/theos/Prefix.pch" 2


# 1 "/Users/brayden/theos/include/HBLog.h" 1
# 19 "/Users/brayden/theos/include/HBLog.h"
# 1 "/Users/brayden/theos/include/CoreFoundation/CFLogUtilities.h" 1
# 35 "/Users/brayden/theos/include/CoreFoundation/CFLogUtilities.h"
#pragma clang module import CoreFoundation.CFBase /* clang -E: implicit import for #include <CoreFoundation/CFBase.h> */
#pragma clang module import CoreFoundation.CFString /* clang -E: implicit import for #include <CoreFoundation/CFString.h> */




enum {
    kCFLogLevelEmergency = 0,
    kCFLogLevelAlert = 1,
    kCFLogLevelCritical = 2,
    kCFLogLevelError = 3,
    kCFLogLevelWarning = 4,
    kCFLogLevelNotice = 5,
    kCFLogLevelInfo = 6,
    kCFLogLevelDebug = 7,
};

extern void CFLog(int32_t level, CFStringRef format, ...);
# 20 "/Users/brayden/theos/include/HBLog.h" 2
# 25 "/Users/brayden/theos/Prefix.pch" 2
# 2 "<built-in>" 2
# 1 "Main.xmi" 2
# 13 "Main.xmi"
# 1 "/Users/brayden/jailbreak/musiclove/MediaRemote.h" 1
# 11 "/Users/brayden/jailbreak/musiclove/MediaRemote.h"
#pragma clang module import CoreFoundation /* clang -E: implicit import for #include <CoreFoundation/CoreFoundation.h> */
# 23 "/Users/brayden/jailbreak/musiclove/MediaRemote.h"
    extern CFStringRef kMRMediaRemoteNowPlayingInfoDidChangeNotification;
    extern CFStringRef kMRMediaRemoteNowPlayingPlaybackQueueDidChangeNotification;
    extern CFStringRef kMRMediaRemotePickableRoutesDidChangeNotification;
    extern CFStringRef kMRMediaRemoteNowPlayingApplicationDidChangeNotification;
    extern CFStringRef kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification;
    extern CFStringRef kMRMediaRemoteRouteStatusDidChangeNotification;



    extern CFStringRef kMRMediaRemoteNowPlayingApplicationPIDUserInfoKey;
    extern CFStringRef kMRMediaRemoteNowPlayingApplicationIsPlayingUserInfoKey;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoAlbum;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoArtist;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoArtworkData;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoArtworkMIMEType;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoChapterNumber;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoComposer;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoDuration;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoElapsedTime;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoGenre;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoIsAdvertisement;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoIsBanned;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoIsInWishList;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoIsLiked;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoIsMusicApp;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoPlaybackRate;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoProhibitsSkip;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoQueueIndex;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoRadioStationIdentifier;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoRepeatMode;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoShuffleMode;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoStartTime;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoSupportsFastForward15Seconds;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoSupportsIsBanned;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoSupportsIsLiked;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoSupportsRewind15Seconds;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoTimestamp;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoTitle;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoTotalChapterCount;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoTotalDiscCount;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoTotalQueueCount;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoTotalTrackCount;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoTrackNumber;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoUniqueIdentifier;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoRadioStationIdentifier;
    extern CFStringRef kMRMediaRemoteNowPlayingInfoRadioStationHash;
    extern CFStringRef kMRMediaRemoteOptionMediaType;
    extern CFStringRef kMRMediaRemoteOptionSourceID;
    extern CFStringRef kMRMediaRemoteOptionTrackID;
    extern CFStringRef kMRMediaRemoteOptionStationID;
    extern CFStringRef kMRMediaRemoteOptionStationHash;
    extern CFStringRef kMRMediaRemoteRouteDescriptionUserInfoKey;
    extern CFStringRef kMRMediaRemoteRouteStatusUserInfoKey;



    typedef enum {



        kMRPlay = 0,
        kMRPause = 1,
        kMRTogglePlayPause = 2,
        kMRStop = 3,
        kMRNextTrack = 4,
        kMRPreviousTrack = 5,
        kMRToggleShuffle = 6,
        kMRToggleRepeat = 7,
        kMRStartForwardSeek = 8,
        kMREndForwardSeek = 9,
        kMRStartBackwardSeek = 10,
        kMREndBackwardSeek = 11,
        kMRGoBackFifteenSeconds = 12,
        kMRSkipFifteenSeconds = 13,







        kMRLikeTrack = 0x6A,
        kMRBanTrack = 0x6B,
        kMRAddTrackToWishList = 0x6C,
        kMRRemoveTrackFromWishList = 0x6D
    } MRCommand;

    Boolean MRMediaRemoteSendCommand(MRCommand command, id userInfo);

    void MRMediaRemoteSetPlaybackSpeed(int speed);
    void MRMediaRemoteSetElapsedTime(double elapsedTime);

    void MRMediaRemoteSetNowPlayingApplicationOverrideEnabled(Boolean enabled);

    void MRMediaRemoteRegisterForNowPlayingNotifications(dispatch_queue_t queue);
    void MRMediaRemoteUnregisterForNowPlayingNotifications();

    void MRMediaRemoteBeginRouteDiscovery();
    void MRMediaRemoteEndRouteDiscovery();

    CFArrayRef MRMediaRemoteCopyPickableRoutes();

    typedef void (^MRMediaRemoteGetNowPlayingInfoCompletion)(CFDictionaryRef information);
    typedef void (^MRMediaRemoteGetNowPlayingApplicationPIDCompletion)(int PID);
    typedef void (^MRMediaRemoteGetNowPlayingApplicationIsPlayingCompletion)(Boolean isPlaying);

    void MRMediaRemoteGetNowPlayingApplicationPID(dispatch_queue_t queue, MRMediaRemoteGetNowPlayingApplicationPIDCompletion completion);
    void MRMediaRemoteGetNowPlayingInfo(dispatch_queue_t queue, MRMediaRemoteGetNowPlayingInfoCompletion completion);
    void MRMediaRemoteGetNowPlayingApplicationIsPlaying(dispatch_queue_t queue, MRMediaRemoteGetNowPlayingApplicationIsPlayingCompletion completion);

    void MRMediaRemoteKeepAlive();
    void MRMediaRemoteSetElapsedTime(double time);
    void MRMediaRemoteSetShuffleMode(int mode);
    void MRMediaRemoteSetRepeatMode(int mode);






    int MRMediaRemoteSelectSourceWithID(CFStringRef identifier);
    void MRMediaRemoteSetPickedRouteWithPassword(CFStringRef route, CFStringRef password);

    CFArrayRef MRMediaRemoteCopyPickableRoutesForCategory(NSString *category);
    Boolean MRMediaRemotePickedRouteHasVolumeControl();
    void MRMediaRemoteSetCanBeNowPlayingApplication(Boolean can);
    void MRMediaRemoteSetNowPlayingInfo(CFDictionaryRef information);
# 14 "Main.xmi" 2
#pragma clang module import SQLite3 /* clang -E: implicit import for #import "sqlite3.h" */
#pragma clang module import ObjectiveC.runtime /* clang -E: implicit import for #import <objc/runtime.h> */




# 1 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm" 1

# 1 "/Users/brayden/jailbreak/musiclove/common.xm" 1





void log(NSString* message) {


 NSLog(@"LOG: %@", message);
 return;

}

void nlog(NSString* message) {
 if(0) log(message);
}

void alert(NSString* title, NSString* message) {
 NSLog(@"ALERT: %@ %@", title, message);

 if(!title || !message) {
  return;
 }



 log(@"Init alert");

 UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title
   message: message
   delegate:((void *)0)
   cancelButtonTitle: @"Close"
   otherButtonTitles:((void *)0)];

 log(@"Showing");
  [alert show];
  [alert release];

}

static const char *getPropertyType(objc_property_t property) {
    const char *attributes = property_getAttributes(property);
    char buffer[1 + strlen(attributes)];
    __builtin___strcpy_chk (buffer, attributes, __builtin_object_size (buffer, 2 > 1 ? 1 : 0));
    char *state = buffer, *attribute;
    while ((attribute = strsep(&state, ",")) != ((void*)0)) {
        if (attribute[0] == 'T') {
            if (strlen(attribute) <= 4) {
                break;
            }
            return (const char *)[[NSData dataWithBytes:(attribute + 3) length:strlen(attribute) - 4] bytes];
        }
    }
    return "@";
}

NSString* getProperty(NSObject* _orig, NSString* key) {
 unsigned int outCount, i;
 objc_property_t *properties = class_copyPropertyList([_orig class], &outCount);


 for(i = 0; i < outCount; i++) {


   objc_property_t property = properties[i];
   if(property == ((void *)0)) {
    continue;
   }
   const char *propName = property_getName(property);
   if(propName) {
     const char *propType = getPropertyType(property);
     NSString *propertyName = [NSString stringWithCString:propName encoding:[NSString defaultCStringEncoding]];
     NSString *propertyType = [NSString stringWithCString:propType encoding:[NSString defaultCStringEncoding]];
     if(propertyName == ((void *)0) || propertyType == ((void *)0)){
      continue;
     }
     nlog([NSString stringWithFormat:@"  -> %@: %@ = %@", propertyName, propertyType, [_orig valueForKey:propertyName]]);


     if([propertyName isEqualToString:key]) {
      free(properties);
      return [_orig valueForKey:propertyName];
     }
   }
 }


 free(properties);
 return ((void *)0);

}
# 3 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm" 2
# 1 "/Users/brayden/jailbreak/musiclove/musictools.xm" 1
static int64_t albumArtistPID = 0;

int64_t getArtistPID(NSString* artist) {
 NSString *filePath = @"/var/mobile/Media/iTunes_Control/iTunes/MediaLibrary.sqlitedb";

 NSFileManager *fileManager = [NSFileManager defaultManager];

 int64_t pid = 0;

 if([fileManager fileExistsAtPath:filePath]){



   const char *dbpath = [filePath UTF8String];
   sqlite3 *db;

   if (sqlite3_open(dbpath, &db) == 0) {


     sqlite3_stmt *statement2;

     NSString* likeStmt = @"SELECT item_artist_pid "
      "FROM item_artist "
      "WHERE item_artist = ?";

     const char *likeStmtStr = [likeStmt UTF8String];


     if (sqlite3_prepare_v2(db, likeStmtStr, -1, &statement2, ((void*)0)) != 0) {
      NSLog(@"Failed to prepare like stmt: %s", sqlite3_errmsg(db));
      sqlite3_close(db);

      return pid;
     }

     if (sqlite3_bind_text(statement2, 1, [artist UTF8String], -1, ((void*)0)) != 0) {
      log([NSString stringWithFormat:@"Failed to bind item_extra: %s", sqlite3_errmsg(db)]);
      sqlite3_close(db);

      return pid;
     }


     log(likeStmt);
     int stepResult = sqlite3_step(statement2);
     if (stepResult == 100 ) {
       pid = sqlite3_column_int64(statement2, 0);




       sqlite3_finalize(statement2);
       sqlite3_close(db);
       return pid;

     } else {
      NSLog(@"Failed to step item_stats query (result = %d)!", stepResult);
     }

     sqlite3_finalize(statement2);
     sqlite3_close(db);
   } else {
     log(@"Failed to open db");
   }
 }else{
  log(@"DB does not exist");

 }
 return pid;
}

int findLikedState(NSString* title, NSString* artist) {
  NSLog(@"findLikedState(%@, %@)", title, artist);
  if(title == ((void *)0)) {
   NSLog(@"<error>: title is nil. Returning 0!");
   return 0;
  }
  if(artist == ((void *)0) || artist.length == 0) {
   NSLog(@"Using album PID: %lld", albumArtistPID);
  }
# 90 "/Users/brayden/jailbreak/musiclove/musictools.xm"
    NSString *filePath = @"/var/mobile/Media/iTunes_Control/iTunes/MediaLibrary.sqlitedb";

    NSFileManager *fileManager = [NSFileManager defaultManager];

    if([fileManager fileExistsAtPath:filePath]){



        const char *dbpath = [filePath UTF8String];
    sqlite3 *db;

        if (sqlite3_open(dbpath, &db) == 0) {


      sqlite3_stmt *statement2;

      if(artist != ((void *)0) && artist.length > 0) {
       NSString* likeStmt = @"SELECT liked_state, item_stats.item_pid, liked_state_changed "
        "FROM item_stats "
        "INNER JOIN item_extra ON item_extra.item_pid = item_stats.item_pid "
        "INNER JOIN item ON item.item_pid = item_stats.item_pid "
        "INNER JOIN item_artist ON item_artist.item_artist_pid = item.item_artist_pid "
        "WHERE item_extra.title = ? AND item_artist.item_artist = ?";

             const char *likeStmtStr = [likeStmt UTF8String];

       NSLog(@"preparing statement: %@", likeStmt);
             if (sqlite3_prepare_v2(db, likeStmtStr, -1, &statement2, ((void*)0)) != 0) {
        NSLog(@"Failed to prepare like stmt: %s", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 0;
       }

       if (sqlite3_bind_text(statement2, 1, [title UTF8String], -1, ((void*)0)) != 0) {
        NSLog(@"Failed to bind item_extra: %s", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 0;
       }
       if (sqlite3_bind_text(statement2, 2, [artist UTF8String], -1, ((void*)0)) != 0) {
        NSLog(@"Failed to bind item_extra: %s", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 0;
       }

      } else {
       NSString* likeStmt = [NSString stringWithFormat:@"SELECT liked_state, item_stats.item_pid, liked_state_changed "
        "FROM item_stats "
        "INNER JOIN item_extra ON item_extra.item_pid = item_stats.item_pid "
        "INNER JOIN item ON item.item_pid = item_stats.item_pid "
        "WHERE item_extra.title = ? AND item.item_artist_pid = %lld", albumArtistPID];

             const char *likeStmtStr = [likeStmt UTF8String];

       NSLog(@"preparing statement: %@!", likeStmt);
             if (sqlite3_prepare_v2(db, likeStmtStr, -1, &statement2, ((void*)0)) != 0) {
        NSLog(@"Failed to prepare like stmt: %s", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 0;
       }

       if (sqlite3_bind_text(statement2, 1, [title UTF8String], -1, ((void*)0)) != 0) {
        log([NSString stringWithFormat:@"Failed to bind item_extra: %s", sqlite3_errmsg(db)]);
        sqlite3_close(db);
        return 0;
       }

      }

      int stepResult = sqlite3_step(statement2);
            if (stepResult == 100 ) {
                int likedState = sqlite3_column_int(statement2, 0);


        NSString* state = @"default";
        if(likedState == 2) {
         state = @"liked";
        }
        if(likedState == 3) {
         state = @"disliked";
        }

        sqlite3_finalize(statement2);
              sqlite3_close(db);
        return likedState;

            } else {
       NSLog(@"<Error> Failed to step item_stats query (result = %d)!", stepResult);
      }

      sqlite3_finalize(statement2);
            sqlite3_close(db);
        } else {
      log(@"Failed to open db");
        }
    }else{
   log(@"DB does not exist");

    }
  return 0;
}
# 4 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm" 2






static NSObject* controller;
# 20 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm"
NSString* getTitle(NSObject* _orig) {
 return getProperty(_orig, @"title");
}
NSString* getArtistName(NSObject* _orig) {
 return getProperty(_orig, @"artistName");
}

void drawLike(UICollectionViewCell* _orig, NSString* title, BOOL likeState) {


 NSString *imageString = [[NSBundle bundleWithPath:@"/Library/Application Support/ca.btraas.musiclove.bundle"] pathForResource:@"heart" ofType:@"png"];



 if(imageString == ((void *)0)) {
  NSLog(@" image is nil");
  return;
 }
 UIImage *heartImage = [UIImage imageWithContentsOfFile:imageString];
 if(heartImage == ((void *)0)) {
  NSLog(@" heartImage is nil");

  return;
 }


 heartImage = [heartImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
 if(heartImage == ((void *)0)) {
  NSLog(@" heartImage is nil");
  return;
 }






 if(likeState == __objc_no) {
  NSLog(@"Clearing heart %@ (likeState=NO)", getTitle(_orig));

  for(UIView* subview in _orig.subviews) {
   if([NSStringFromClass([subview class]) isEqualToString:@"UIImageView"]) {
    NSLog(@"subview origin.x: %f", subview.frame.origin.x);

    if(subview.frame.origin.x <= 15 && subview != ((void *)0)) {

      NSLog(@"     -> origin < 15. Removing now! (this is a previously added heart)");
      if(subview != ((void *)0)) {
       [subview removeFromSuperview];
      }

    }
   }
  }
 } else {
  NSLog(@"Adding heart %@ (likeState=YES)", getTitle(_orig));



  CGRect frame = CGRectMake( (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad ? 0 : 3.5), 17.5, 14, 14);
# 96 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm"
  UIImageView *newView = [[UIImageView alloc] initWithFrame:frame];




  if(newView != ((void *)0)) {
   [newView setBackgroundColor:[UIColor whiteColor]];
   [newView setTintColor:[UIColor redColor]];
   [newView setImage:heartImage];

   if(_orig != ((void *)0) && _orig.contentView != ((void *)0) && _orig.contentView.window != ((void *)0)) {
    NSLog(@"adding heart");

    [_orig.contentView addSubview:newView];
    [_orig.contentView bringSubviewToFront:newView];

   }

  }
 }

}



%hook CompositeCollectionViewController





  -(UICollectionReusableView *)collectionView:(UICollectionView*)cv viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {

  UICollectionReusableView* _orig = %orig(cv, kind, indexPath);


  if(controller != self && kind != ((void *)0) && [kind isEqualToString:@"UICollectionElementKindGlobalHeader"] && _orig != ((void *)0)) {

   for (UIView *subview in _orig.subviews){
    if(subview != ((void *)0) && [NSStringFromClass([subview class]) isEqualToString:@"Music.ContainerDetailHeaderLockupView"])

     for(UIView *lockupSubview in subview.subviews) {
      NSString* lsClass = NSStringFromClass([lockupSubview class]);

      if(lsClass != ((void *)0) && [lsClass isEqualToString:@"UIButton"]) {
       UILabel* titleLabel = ((UIButton *)lockupSubview).titleLabel;
       if(titleLabel != ((void *)0) && [titleLabel isKindOfClass:[UILabel class]]) {
        NSString* text = titleLabel.text;

        NSLog(@"");
        NSLog(@"Setting album artist: %@", text);


        if([text isKindOfClass:[NSString class]]) {
         albumArtistPID = getArtistPID(titleLabel.text);
         NSLog(@"Album artist PID: %lld", albumArtistPID);

         controller = self;




        }

       }
      }
     }

   }
  }
  return _orig;
 }





 -(UICollectionViewCell *)collectionView:(id)cv cellForItemAtIndexPath:(NSIndexPath *)indexPath {

  UICollectionViewCell* _orig = %orig(cv, indexPath);
  if(_orig == ((void *)0)) {
   return _orig;
  }


  if([NSStringFromClass([_orig class]) isEqualToString:@"Music.SongCell"]) {
    NSLog(@"");
    NSLog(@"Got SongCell");

    __attribute__((__blocks__(byref))) int isLiked = 0;
    NSString* title = getTitle(_orig);
    NSString* artist = getArtistName(_orig);
    int likeState = findLikedState(title, artist);

    NSLog(@"Cell = %@/%@, state=%d",title,artist,likeState);





    for(UIView* subview in _orig.contentView.subviews) {
     NSLog(@"Checking subview:  %@ at origin.x: %f", NSStringFromClass([subview class]), subview.frame.origin.x );

     if([NSStringFromClass([subview class]) isEqualToString:@"UIImageView"]) {
      NSLog(@"Removing subview: %@  %@", title, NSStringFromClass([subview class] ));

       [subview removeFromSuperview];
# 225 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm"
     }
    }
# 247 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm"
      if(likeState != 2) {


        if(title == getTitle(_orig))
          drawLike(_orig, title, __objc_no);

      } else {
       isLiked = 1;



       if(title == getTitle(_orig))
        drawLike(_orig, title, __objc_yes);

      }





      NSLog(@"%@: is liked? %@", title, isLiked > 0 ? @"TRUE" : @"FALSE");
      if(isLiked <= 0) {

      }






       for (UIView *subview in _orig.contentView.subviews){

        if([NSStringFromClass([subview class]) isEqualToString:@"_TtCV5Music4Text9StackView"] && [subview.subviews count] > 0){



          NSLog(@"%@ star (1) (origin.x=%f)", (isLiked > 0 ? @"hiding":@"showing"), subview.frame.origin.x);


         for(UIView* textStackView in subview.subviews) {
          NSLog(@"star(1.5) origin.x: %f", textStackView.frame.origin.x);


          if(textStackView != ((void *)0) && subview.frame.origin.x <= 15) {


           NSLog(@"%@ star (2)", isLiked > 0 ? @"hiding":@"showing");

           [textStackView setHidden:(isLiked==1)];
# 307 "/Users/brayden/jailbreak/musiclove/PlaylistAndAlbum.xm"
          }
         }






        }
       }





  }

  return _orig;

}
%end



%ctor {


    %init(CompositeCollectionViewController = objc_getClass("Music.CompositeCollectionViewController"));


}
# 21 "Main.xmi" 2
# 1 "/Users/brayden/jailbreak/musiclove/Songs.xm" 1
# 22 "Main.xmi" 2

